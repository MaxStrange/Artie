"""
All the machinery for the status command.
"""
from .. import common
from .. import docker
from .. import hw_config
from .. import kube
from ..infrastructure import run
from ..infrastructure import task
from ..infrastructure import task_importer
from collections.abc import Iterable
import argparse
import enum
import os

class LogOptions(enum.Enum):
    """Options for fetching logs along with status"""
    NONE = ("none", "Do not fetch logs.")
    ALL = ("all", "Fetch all logs pertaining to the status being queried.")
    GENERATED = ("generated", "Fetch only logs generated by the item whose status is being queried.")

def _list_actuators(args, artie_hw_config: hw_config.HWConfig):
    """List all actuators for this Artie"""
    common.info("Actuators:")
    for actuator in artie_hw_config.actuators:
        common.info(f"  - {actuator.name} (type: {actuator.type}, bus: {actuator.bus})")

def _list_mcus(args, artie_hw_config: hw_config.HWConfig):
    """List all MCUs for this Artie"""
    common.info("Microcontrollers:")
    for mcu in artie_hw_config.mcus:
        common.info(f"  - {mcu.name} (buses: {', '.join(mcu.buses)})")

def _list_nodes(args, artie_hw_config: hw_config.HWConfig):
    """List all nodes for this Artie"""
    common.info(f"Nodes for Artie '{args.artie_name}':")
    for sbc in artie_hw_config.sbcs:
        node_name = f"{sbc.name}-{args.artie_name}"
        common.info(f"  - {node_name} (SBC: {sbc.name})")

def _list_pods(args):
    """List all pods in the artie namespace"""
    import kubernetes as k8s
    kube._configure(args)
    v1 = k8s.client.CoreV1Api()
    
    try:
        pods = v1.list_namespaced_pod(namespace=kube.ArtieK8sValues.NAMESPACE)
        common.info(f"Pods in namespace '{kube.ArtieK8sValues.NAMESPACE}':")
        for pod in pods.items:
            common.info(f"  - {pod.metadata.name}")
    except Exception as e:
        common.error(f"Error listing pods: {e}")

def _list_sensors(args, artie_hw_config: hw_config.HWConfig):
    """List all sensors for this Artie"""
    common.info("Sensors:")
    for sensor in artie_hw_config.sensors:
        common.info(f"  - {sensor.name} (type: {sensor.type}, bus: {sensor.bus})")

def _print_actuator_status(args, actuator: hw_config.Actuator):
    """Print status information for a single actuator."""
    common.info(f"Actuator: {args.actuator}")
    common.info(f"  Type: {actuator.type}")
    common.info(f"  Bus: {actuator.bus}")
    common.info(f"  Status: [Not implemented - requires CAN bus integration]")

def _print_mcu_status(args, mcu: hw_config.MCU):
    """Print status information for a single MCU."""
    common.info(f"MCU: {mcu.name}")
    common.info(f"  Buses: {', '.join(mcu.buses)}")
    common.info(f"  Heartbeat: [Not implemented - requires CAN bus integration]")

def _print_node_status(args, node: hw_config.SBC):
    """Print status information for a single node"""
    node_name = f"{node.name}-{args.artie_name}"
    try:
        if kube.node_is_online(args, node_name):
            labels = kube.get_node_labels(args, node_name)
            role = labels.get(kube.ArtieK8sKeys.NODE_ROLE, "unknown")
            common.info(f"Node: {node_name}")
            common.info(f"  Status: ONLINE")
            common.info(f"  Role: {role}")
            common.info(f"  Artie: {args.artie_name}")
        else:
            common.warning(f"Node: {node_name}")
            common.warning(f"  Status: OFFLINE or NOT READY")
    except Exception as e:
        common.error(f"Error getting status for node {node.name}: {e}")

def _print_pod_status(args, pod):
    """Print status information for a single pod."""
    common.info(f"Pod: {pod.metadata.name}")
    common.info(f"  Status: {pod.status.phase}")
    common.info(f"  Node: {pod.spec.node_name}")
    if pod.status.container_statuses:
        for container in pod.status.container_statuses:
            common.info(f"  Container: {container.name}")
            common.info(f"    Ready: {container.ready}")
            common.info(f"    Restart Count: {container.restart_count}")
            if container.state:
                common.info(f"    State: {container.state}")


def _print_sensor_status(args, sensor: hw_config.Sensor):
    """Print status information for a single sensor."""
    common.info(f"Sensor: {sensor.name}")
    common.info(f"  Type: {sensor.type}")
    common.info(f"  Bus: {sensor.bus}")
    common.info(f"  Status: [Not implemented - requires CAN bus integration]")

def _get_actuators_status(args, artie_hw_config: hw_config.HWConfig):
    """Get status for actuator(s)"""
    if args.list:
        _list_actuators(args, artie_hw_config)
        return
    
    # Possibly get status for all actuators
    if args.actuator == "all":
        common.info("Actuator Status:")
        for actuator in artie_hw_config.actuators:
            _print_actuator_status(args, actuator)
        return

    # Get status for specific actuator
    actuator_found = False
    for actuator in artie_hw_config.actuators:
        if actuator.name == args.actuator:
            actuator_found = True
            _print_actuator_status(args, actuator)
            break
    
    if not actuator_found:
        actuator_names = [actuator.name for actuator in artie_hw_config.actuators]
        common.error(f"Actuator '{args.actuator}' not found in hardware configuration. Available actuators: {actuator_names}")

def _get_mcus_status(args, artie_hw_config: hw_config.HWConfig):
    """Get status for MCU(s)"""
    if args.list:
        _list_mcus(args, artie_hw_config)
        return
    
    # Possibly get status for all MCUs
    if args.mcu == "all":
        common.info("MCU Status:")
        for mcu in artie_hw_config.mcus:
            _print_mcu_status(args, mcu)
        return

    # Get status for specific MCU
    mcu_found = False
    for mcu in artie_hw_config.mcus:
        if mcu.name == args.mcu:
            mcu_found = True
            _print_mcu_status(args, mcu)
            break
    
    if not mcu_found:
        mcu_names = [mcu.name for mcu in artie_hw_config.mcus]
        common.error(f"MCU '{args.mcu}' not found in hardware configuration. Available MCUs: {mcu_names}")

def _get_nodes_status(args, artie_hw_config: hw_config.HWConfig):
    """Get status for node(s)"""
    if args.list:
        _list_nodes(args, artie_hw_config)
        return
    
    # Possibly get status for all nodes
    if args.node == "all":
        common.info("Node Status:")
        for sbc in artie_hw_config.sbcs:
            _print_node_status(args, sbc)
        return

    # Get status for a specific node
    node_found = False
    for node in artie_hw_config.sbcs:
        if sbc.name == args.node:
            node_found = True
            _print_node_status(args, node)
            break

    if not node_found:
        node_names = [sbc.name for sbc in artie_hw_config.sbcs]
        common.error(f"Node '{args.node}' not found in hardware configuration. Available nodes: {node_names}")

def _get_pods_status(args):
    """Get status for pod(s)"""
    if args.list:
        _list_pods(args)
        return

    # Get all the pods regardless
    try:
        pods = kube.get_all_pods(args)
    except Exception as e:
        common.error(f"Error getting pod status: {e}")
        return

    # Possibly get status for all pods
    if args.pod == "all":
        common.info("Pod Status:")
        for pod in pods:
            _print_pod_status(args, pod)
        return

    # Get status for a specific pod
    pod_found = False
    for pod in pods:
        if pod.metadata.name == args.pod:
            pod_found = True
            _print_pod_status(args, pod)
            break

    if not pod_found:
        pod_names = [pod.metadata.name for pod in pods]
        common.error(f"Pod '{args.pod}' not found in Kubernetes. Available pods: {pod_names}")

def _get_sensors_status(args, artie_hw_config: dict):
    """Get status for sensor(s)"""
    if args.list:
        _list_sensors(args, artie_hw_config)
        return
    
    # Possibly get status for all sensors
    if args.sensor == "all":
        common.info("Sensor Status:")
        for sensor in artie_hw_config.sensors:
            _print_sensor_status(args, sensor)
        return

    # Get status for specific sensor
    sensor_found = False
    for sensor in artie_hw_config.sensors:
        if sensor.name == args.sensor:
            sensor_found = True
            _print_sensor_status(args, sensor)
            break
    
    if not sensor_found:
        sensor_names = [sensor.name for sensor in artie_hw_config.sensors]
        common.error(f"Sensor '{args.sensor}' not found in hardware configuration. Available sensors: {sensor_names}")

def status(args):
    """
    Top-level status function.
    """
    retcode = 0

    # For pods, we don't need HW config
    if args.module == "pods":
        _get_pods_status(args)
        return retcode

    # Otherwise, access the Artie cluster to determine what type of Artie we have
    try:
        # After this call, `args` will have `artie_name` populated
        artie_hw_config = kube.get_artie_hw_config(args)
    except ValueError as e:
        common.error(f"Cannot get Artie's HW configuration: {str(e)}")
        retcode = 1
        return retcode
    except KeyError as e:
        common.error(f"Cannot get Artie's HW configuration: {str(e)}")
        retcode = 1
        return retcode

    match args.module:
        case "nodes":
            _get_nodes_status(args, artie_hw_config)
        case "mcus":
            _get_mcus_status(args, artie_hw_config)
        case "actuators":
            _get_actuators_status(args, artie_hw_config)
        case "sensors":
            _get_sensors_status(args, artie_hw_config)
        case _:
            common.error(f"Unknown status module: {args.module}")
            retcode = 1

    return retcode

def fill_subparser(parser_status: argparse.ArgumentParser, parent: argparse.ArgumentParser):
    subparsers = parser_status.add_subparsers(title="status-module", description="Choose what status to get")

    # Args that are useful for all status commands
    option_parser = argparse.ArgumentParser(parents=[parent], add_help=False)
    group = option_parser.add_argument_group("Status", "Status Options")
    group.add_argument("--timeout-s", type=int, default=30, help="Timeout in seconds for status operations (default: 30s)")
    group.add_argument("--logs", choices=[option.value[0] for option in LogOptions], default=LogOptions.NONE.value[0], help=f"Whether to fetch logs along with status. Chooses from: {list(zip([option.value[0] for option in LogOptions], [option.value[1] for option in LogOptions]))} (default: {LogOptions.NONE.value[0]})")
    group.add_argument("--list", action='store_true', help="If given, we will list the available items instead of getting status for a specific item.")

    # Add all the status tasks
    node_parser = subparsers.add_parser("nodes", parents=[option_parser])
    node_parser.add_argument("--node", "-n", default="all", type=str, help="The node to get status for. If not given, we get the status for all nodes.")
    node_parser.set_defaults(cmd=status, module="nodes")

    pod_parser = subparsers.add_parser("pods", parents=[option_parser])
    pod_parser.add_argument("--pod", "-p", default="all", type=str, help="The pod to get status for. If not given, we get the status for all pods.")
    pod_parser.set_defaults(cmd=status, module="pods")

    mcu_parser = subparsers.add_parser("mcus", parents=[option_parser])
    mcu_parser.add_argument("--mcu", "-m", default="all", type=str, help="The MCU to get heartbeat status for. If not given, we get the status for all MCUs.")
    mcu_parser.set_defaults(cmd=status, module="mcus")

    actuator_parser = subparsers.add_parser("actuators", parents=[option_parser])
    actuator_parser.add_argument("--actuator", "-a", default="all", type=str, help="The actuator to get status for. If not given, we get the status for all actuators.")
    actuator_parser.set_defaults(cmd=status, module="actuators")

    sensor_parser = subparsers.add_parser("sensors", parents=[option_parser])
    sensor_parser.add_argument("--sensor", "-s", default="all", type=str, help="The sensor to get status for. If not given, we get the status for all sensors.")
    sensor_parser.set_defaults(cmd=status, module="sensors")


    # TODO: This module needs to print the status information with a stable API so that workbench can make use of it. Possibly just print out a YAML or JSON version of the information.
